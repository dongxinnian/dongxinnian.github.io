{"meta":{"title":"新年","subtitle":"如果不是我那会是谁，如果不是现在，那是什么时候？","description":"一个可以肆意放肆的地方","author":"luckynian","url":"http://yoursite.com"},"pages":[{"title":"随笔","date":"2016-12-14T06:31:02.000Z","updated":"2016-12-14T06:31:02.423Z","comments":true,"path":"随笔/index.html","permalink":"http://yoursite.com/随笔/index.html","excerpt":"","text":""}],"posts":[{"title":"stopPropagation,preventDefault和return false的区别","slug":"stopPropagation-preventDefault和return-false的区别","date":"2017-07-17T14:58:43.000Z","updated":"2017-07-17T15:20:49.176Z","comments":true,"path":"2017/07/17/stopPropagation-preventDefault和return-false的区别/","link":"","permalink":"http://yoursite.com/2017/07/17/stopPropagation-preventDefault和return-false的区别/","excerpt":"因为有父子节点同在，有监听事件和浏览器默认动作之分，使用javascript时为了达到预期效果经常要阻止事件和动作的执行，一般会用到三种方法分别是stopPropagation( ), preventDefault( )和return false;它们之间有什么区别，该何时使用呢？","text":"因为有父子节点同在，有监听事件和浏览器默认动作之分，使用javascript时为了达到预期效果经常要阻止事件和动作的执行，一般会用到三种方法分别是stopPropagation( ), preventDefault( )和return false;它们之间有什么区别，该何时使用呢？ 监听事件：在节点上能被监听时的页面操作。如：select节点的change事件，a节点的click事件。浏览器默认动作：指特定页面元素上带有的功能，如：点击a链接时的跳转动作，表单提交动作等； stopPropagation( )因为事件可以在各层级的节点中传递，不管是冒泡还是捕获，有时我们希望事件在特定节点执行之后不再传递，可以使事件对象的stopPropagation( )方法； 假设页面上存在一个浮动弹出层, 显示在最前面, 当点击弹出层以外页面区域时, 隐藏弹出层. 为了做到这样的效果, 我们会监听 documentElement 的 click 事件, 一旦事件被触发即隐藏弹出层. 但是这显然存在问题.当用户点击弹出层时, 我们不希望它隐藏掉.但因为事件的冒泡传递,documentElement的click事件也会被触发. 这个时候,我们可以监听弹出层的click事件,并使用stopPropagation() 方法阻止冒泡. 请参考下面的代码. 12345678910// 在弹出对话框上点击时, 不进行任何页面操作, 并阻止冒泡document.getElementById(&apos;dialog&apos;).onclick = function(ev) &#123; ev.stopPropagation();&#125;;// 在 documentElement 节点上监听到点击事件时, 隐藏对话框document.documentElement.onclick = function(ev) &#123; document.getElementById(&apos;dialog&apos;).style.display = &apos;none&apos;;&#125;; stopPropagation() 相当好用, 可是 IE8 及以前版本都不支持. IE 的事件对象包含特有的属性 cancelBubble, 只要将它赋值为 false 即可阻止事件继续. 如:12345// 在弹出对话框上点击时, 不进行任何页面操作, 并阻止冒泡document.getElementById(&apos;dialog&apos;).onclick = function(ev) &#123; ev.cancelBubble = false;&#125;; preventDefault( )一个带事件监听的链接代码如下:1&lt;a href=&quot;http://w3c.org&quot; onclick=&quot;alert(&apos;JavaScript Click Event&apos;);&quot;&gt;点击链接&lt;/a&gt; 点击该链接, 显示对话框后跳转页面. 由此可知, 除了执行监听事件还会触发浏览器默认动作; 执行监听事件在前, 触发浏览器默认动作在后.这里有个经典示例, 我们希望点击链接在新窗口打开页面, 但不希望当前页面跳转. 这个时候可以使用 preventDefault() 阻止后面将要执行的浏览器默认动作.1234567891011&lt;a id=&quot;link&quot; href=&quot;http://w3c.org&quot;&gt;W3C 首页链接&lt;/a&gt; &lt;script&gt;// 在新窗口, 打开页面document.getElementById(&apos;link&apos;).onclick = function(ev) &#123; // 阻止浏览器默认动作 (页面跳转) ev.preventDefault(); // 在新窗口打开页面 window.open(this.href);&#125;;&lt;/script&gt; return false退出执行, return false 之后的所有触发事件和动作都不会被执行. 有时候 return false 可以用来替代 stopPropagation() 和 preventDefault(), 比如我们上面新窗口打开链接的例子, 如:1234567891011&lt;a id=&quot;link&quot; href=&quot;http://w3c.org&quot;&gt;W3C 首页链接&lt;/a&gt; &lt;script&gt;// 在新窗口, 打开页面document.getElementById(&apos;link&apos;).onclick = function(ev) &#123; // 在新窗口打开页面 window.open(this.href); // 退出执行 (在监听事件之后执行的浏览器默认动作将不会被执行) return false;&#125;;&lt;/script&gt; 有人认为return false = stopPropagation() + preventDefault() 其实是错的. return false 不但阻止事件, 还可以返回对象, 跳出循环等… 方便地一刀切而不够灵活, 滥用易出错.","categories":[{"name":"编程","slug":"编程","permalink":"http://yoursite.com/categories/编程/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"}]},{"title":"操作array的方法","slug":"操作array的方法","date":"2017-07-01T07:17:35.000Z","updated":"2017-07-01T08:22:39.069Z","comments":true,"path":"2017/07/01/操作array的方法/","link":"","permalink":"http://yoursite.com/2017/07/01/操作array的方法/","excerpt":"1.array.push(); 作用： 添加一个或多个元素到数组的头部； 语法1number arr.push(element1, ..., elementN)；","text":"1.array.push(); 作用： 添加一个或多个元素到数组的头部； 语法1number arr.push(element1, ..., elementN)； 参数： elementN：一个或多个元素 返回值: 新数组的length 2.arr.unshift() 作用: 添加一个或多个元素到数组的头部; 语法: 1number arr.unshift(element1, ..., elementN) 参数: elementN：一个或多个元素 返回值： 新数组的length； 3.arr.pop() 作用： 删除数组最后一个元素； 语法： 1mixed arr.pop() 返回值: 被删除的那一个元素; 4.arr.shift() 作用: 删除数组第一个元素 语法: 1number arr.shift() 返回值: 被删除的那一个元素; 5.arr.sort() 作用: 对数组的元素进行排序 语法: 1array arr.sort([compareFunction]) 参数 compareFunction : 可选。用来指定按某种顺序进行排列的函数。如果省略，元素按照转换为的字符串的诸个字符的Unicode位点进行排序。 返回值: 排序后的数组 如图： 6.arr.concat() 作用： 将传入的数组或非数组值与原数组合并,组成一个新的数组并返回 语法： 1array array.concat(value1, value2, ..., valueN) 参数: valueN 需要与原数组合并的数组或非数组值. 返回值: 合并后的数组 如图: 7.arr.reverse() 作用: 颠倒数组中元素的位置; 语法: 1array arr.reverse() 返回值 颠倒顺序后的数组; 8.arr.join() 作用: 将数组中的所有元素连接成一个字符串; 语法: 1string arr.join([separator = &apos;,&apos;]) 参数; separator： 可选，用于指定连接每个数组元素的分隔符。分隔符会被转成字符串类型；如果省略的话，默认为一个逗号。如果 seprator 是一个空字符串，那么数组中的所有元素将被直接连接。 返回值： 拼接后的字符串； 例子如图： 9.arr.slice() 作用： 截取数组中一部分，并返回这个新的数组。 语法： 1array arr.slice([begin[，end]]) 参数: begin : 起始位置 end : 结束位置，不包含在内 返回值: 截取后的新的数组; 如图： 10.arr.splice() 作用： 用新元素替换旧元素，以此修改数组的内容 语法： 1array array.splice(start, deleteCount[, item1[, item2[, ...]]]) 参数: start: 起始位置; deleteCount: 删除长度; item: 添加的内容; 返回值: 由被删除的元素组成的一个数组;","categories":[{"name":"编程","slug":"编程","permalink":"http://yoursite.com/categories/编程/"}],"tags":[{"name":"array 前端","slug":"array-前端","permalink":"http://yoursite.com/tags/array-前端/"}]},{"title":"字符串操作方法","slug":"字符串操作方法","date":"2017-07-01T05:48:59.000Z","updated":"2017-07-01T08:48:45.326Z","comments":true,"path":"2017/07/01/字符串操作方法/","link":"","permalink":"http://yoursite.com/2017/07/01/字符串操作方法/","excerpt":"什么是字符串？ 使用一对单引号或双引号包含起来的由0或多个字符组成，同时具有length属性 “” 空字符串 “ “ 空白字符串 ‘dong’ 单引号； “dong” 双引号；","text":"什么是字符串？ 使用一对单引号或双引号包含起来的由0或多个字符组成，同时具有length属性 “” 空字符串 “ “ 空白字符串 ‘dong’ 单引号； “dong” 双引号； 1.charAt 作用： 方法返回字符串中指定位置的字符 语法： 1String String.charAt(index); 参数index 0到String.length-1的一个整数； 返回值 返回字符串；（当index小于0，或大于等于字符串长度时，返回空字符串） 2.charCodeAt 作用： 返回指定索引处字符的 Unicode 数值 语法： 1number str.charCodeAt(index) 参数 index:一个大于等于 0，小于字符串长度的整数。如果不是一个数值，则默认为 0。 返回值： 返回指定索引处字符的 Unicode 数值 3.indexOf 作用： 返回指定值在调用该方法的字符串中首次出现的位置; 语法： 1number string.indexOf(searchValue [, fromIndex]) 参数： searchValue：一个字符串表示需要被查找的值；（必填） fromIndex：开始查找的位置，默认值为0；（选填） 返回值： 返回字符串所在位置的index数字，如果存在返回位置，如果不存在返回-1 4.lastIndexOf 作用： 返回指定值在调用该方法的字符串中最后出现的位置 语法： 1number string.lastIndexOf(searchValue [, fromIndex]) 参数： searchValue：一个字符串表示被查找的值；（必填） fromIndex：开始查找的位置，默认值为str.length-1；（选填） 返回值： 返回数字，如果存在返回位置，如果不存在返回-1； 5.slice 作用： 提取字符串中的一部分，并返回这个新的字符串； 语法： 1string string.slice(beginSlice[, endSlice]) 参数： beginSlice：起始位置；如果值为负数则从后往前开始截取； endSlice： 结束位置，一般会向前一位截取，默认为最后一个字符的位置； 返回值: 返回截取后的字符串例子： 6.split 作用: 通过一个指定的字符串把原字符串分割成一个数组; 语法: 1array string.split([separator] [, limit]) 参数： separator： 分隔符； limit：指定最多分割的数量，默认为全部； 返回值： 返回一个数组，当没有分割符的时候，整个字符串将作为一个整体保存到数组中 7.substring 作用： 截取指定位置之间的字符串； 语法： 1string string.substring(indexStart [, indexEnd]) 参数： indexStart：截取的起始位置 负数不起作用； indexEnd：截取的结束位置，默认为最后一个字符的位置； 返回值： 返回截取后的字符串；例子： 8.substr 作用: 截取指定起始位置和长度的字符串; 语法: 1string string.substr(start [, length]) 参数: start:截取的起始位置; length: 截取的字符串长度，默认为起始位置到最后一个字符的字符长度 返回值: 返回截取后的字符串; 例子： 9.toLowerCase 作用: 把字符串全部转成小写; 语法: 1string string.toLowerCase() 返回值： 返回转成小写的字符串; 10.toUpperCase 作用： 把字符串全部转成大写 语法： 1string string.toUpperCase() 返回值： 返回转成大写的字符串；","categories":[{"name":"编程","slug":"编程","permalink":"http://yoursite.com/categories/编程/"}],"tags":[{"name":"字符串 前端","slug":"字符串-前端","permalink":"http://yoursite.com/tags/字符串-前端/"}]},{"title":"Hexo搭建个人博客","slug":"hexo搭建个人博客","date":"2017-06-30T07:41:36.000Z","updated":"2017-06-30T10:00:45.342Z","comments":true,"path":"2017/06/30/hexo搭建个人博客/","link":"","permalink":"http://yoursite.com/2017/06/30/hexo搭建个人博客/","excerpt":"下面来为大家详细介绍如何通过githubPages和Hexo来搭建博客. 什么是GithubPages和HexoGitHub是一个代码托管网站和编程社交网站（俗称“全球最大同性恋交友网站”）这里聚集了全世界各路技术大牛； GithubPages有什么作用 是用来托管GitHub上静态网页的免费站点。 有300M免费空间 可以使用很多现成博客框架，搭建过程简单快速；","text":"下面来为大家详细介绍如何通过githubPages和Hexo来搭建博客. 什么是GithubPages和HexoGitHub是一个代码托管网站和编程社交网站（俗称“全球最大同性恋交友网站”）这里聚集了全世界各路技术大牛； GithubPages有什么作用 是用来托管GitHub上静态网页的免费站点。 有300M免费空间 可以使用很多现成博客框架，搭建过程简单快速； HEXOHexo是一个简单，快速，强大的静态博客框架，出自台湾大学生tommy351之手。Hexo的四大特点： 能快速生成博客 一键部署博客 丰富的插件支持 支持Markdown 使用GitHub Pages建立站点注册GitHub如下图，建议使用自己常用的邮箱进行注册，防止遗忘；![注册成功后，到GitHub官网登录，验证邮箱即可 在GitHub上建立仓库GitHubPages分为两种，一种是用你的GitHub用户名建立的username.github.io这样的用户名&amp;站点，另一种是依附项目的pages；向建立个人博客就用第一种，username.github.io这样的站点每个用户名下只能建立一个。步骤如下图所示 搭建环境1.1 安装node和Git 要使用hexo得先保证你得电脑已经安装了Node.js及Git如果没有请先安装好1.2 安装Hexo 我们前面已经安装好了Git，现在可以派上用场了。回到桌面点击右键，选择Git Bash,如图打开GitBash后我们输入安装hexo的命令1npm install -g hexo-cli 看到这条信息表示安装成功；接下来我们要选择一个文件夹目录来存放hexo的文件，例如我在E盘手动创建了一个blog的文件夹，把Git的目录切换的E盘的blog文件夹下执行以下命令进行初始化1hexo init 回车后出现以下信息表示初始化成功初始化成功之后，Hexo会自动在目标文件夹建立博客网站所需要的所有文件。此时可以通过输入以下命令在本地进行预览（在刚才创建的文件夹里）：12hexo generate hexo server 如下图所示表示成功；此时打开浏览器，在浏览器地址栏输入http://localhost:4000/（默认端口为4000）, 便可以看到最原始的博客了。以后发表博文想先预览，也可以通过 hexo server 在本地先跑起来，看看效果。效果如下图所示：恭喜，到目前为止个人博客的雏形已经有了。在 Git Shell 中按 Ctrl + C 并输入 y 可以停止该服务。 Hexo 几个常用的命令：12345hexo generate (hexo g) 生成静态文件，会在当前目录下生成一个新的叫做public的文件夹hexo server (hexo s) 启动本地web服务，用于博客的预览hexo deploy (hexo d) 部署博客到远端服务器hexo new &quot;postName&quot; #新建文章hexo new page &quot;pageName&quot; #新建页面 可以简写成1234$ hexo n == hexo new$ hexo g == hexo generate$ hexo s == hexo server$ hexo d == hexo deploy 都是这些单词的首字母，更多的命令用法，可以参考Hexo官网 配置SSH上传文件需要配置ssh key,不然无法上传。首先检测下本地是否已经存在ssh key,在Git Bash输入以下指令，检查是否已经存在ssh key；1ls -al ~/.ssh 如果不存在我们稍后创建，如果存在，直接删掉.ssh文件夹中的所有文件 生成SSH密钥输入以下指令（邮箱就是你注册Github时候的邮箱）后，回车：1ssh-keygen -t rsa -C &quot;XXXXX@qq.com&quot; 一路按回车键即可，如果设置了密码请记住。这一步在~/.ssh/下生成了两个文件id_rsa 和 id_rsa.pub 设置name和emai12git config --global user.name &quot;&lt;your name&gt;&quot;git config --global user.email &quot;&lt;your email&gt;&quot; 需要注意的是这里的name是随意的，邮箱是你的联系邮箱，与github上的邮箱没有什么联系（不过我都是同一个邮箱）。 获取Key1$ cat ~/.ssh/id_rsa.pub 然后拷贝key 在Github上添加SSH密钥在https://github.com/settings/keys下 add new ssh key然后title随便取个名字，key 就是上面我们拷贝的内容，好了，最后我们测试一下看是否配置成功。输入以下命令：1ssh git@github.com 成功的话会显示以下的大致内容：123456The authenticity of host &apos;github.com (192.30.252.128)&apos; can&apos;t be established.RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.Are you sure you want to continue connecting (yes/no)? yesWarning: Permanently added &apos;github.com,192.30.252.128&apos; (RSA) to the list of known hosts.Hi git-xuhao! You&apos;ve successfully authenticated, but GitHub does not provide shell access.Connection to github.com closed. 将本地文件部署到 GitHub修改 Hexo 中的 _config.yml 文件在 Hexo 文件夹下找到 _config.yml 文件,如下图所示：找到其中的 deploy 标签，改成下图所示形式，并保存。注意：冒号后面要加上一个空格，否则会报错。 将其 deploy 到仓库中安装Git包，执行以下命令1npm install hexo-deployer-git --save 部署到GitHub上，执行以下的命令1hexo deploy 现在我们可以通过访问 http://username.github.io/ 来访问我们自己的博客啦,可以看到我们的博客已成功搭建，接下来就是一些主题的优化和配置呢。 Hexo配置文件hexo里面有两个常用到的配置文件，分别是整个博客根目录的配置文件_config.yml和主题的配置文件hexo\\themes\\next_config.yml，hexo3.0使用的默认主题是landscape，所以你们对应的地址为Ehexo\\themes\\landscape_config.yml；hexo提供了很多个主题供你自己选择，使用方法很简单，找到自己喜欢主题Repository，使用Git将主题clone到本地，然后将整个文件夹复制到themes文件夹下，将_config.yml里的theme名字改为自己下载的主题的文件夹名就可以了。 配置文件说明如下：根目录下的_config.yml1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980# Hexo Configuration## Docs: http://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Site 这下面的几项配置都很简单，你看我的博客就知道分别是什么意思title: blog name #博客名subtitle: Goals determine what you are going to be #副标题description: Goals determine what you are going to be #用于搜索，没有直观表现author: huangjunhui #作者language: zh-CN #语言timezone: #时区，此处不填写，hexo会以你目前电脑的时区为默认值# URL 暂不配置，使用默认值## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;url: http://yoursite.comroot: /permalink: :year/:month/:day/:title/permalink_defaults:# Directory 暂不配置，使用默认值source_dir: sourcepublic_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: :langskip_render:# Writing 文章布局等，使用默认值new_post_name: :title.md # File name of new postsdefault_layout: posttitlecase: false # Transform title into titlecaseexternal_link: true # Open external links in new tabfilename_case: 0render_drafts: falsepost_asset_folder: falserelative_link: falsefuture: truehighlight: enable: true line_number: true tab_replace:# Category &amp; Tag 暂不配置，使用默认值default_category: uncategorizedcategory_map:tag_map:# Date / Time format 时间格式，使用默认值## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss# Pagination ## Set per_page to 0 to disable paginationper_page: 10 #每页显示的文章数，0表示不分页pagination_dir: page# Extensions 插件配置，暂时不配置## Plugins: http://hexo.io/plugins/## Themes: http://hexo.io/themes/plugins:- hexo-generator-feedtheme: light #使用的主题feed: #之后配置rss会用，此处先不配置这个 type: atom path: atom.xml limit: 20 # Deployment 用于部署到github，之前已经配置过## Docs: http://hexo.io/docs/deployment.htmldeploy: type: git repo: ssh://git@github.com/git-xuhao/git-xuhao.github.io branch: master 如何使用1hexo new &quot;name&quot; name为博文的名字，建立完成之后，可以在./source/_posts文件夹下发现我们刚刚建立的 name.md文件。使用你熟悉的编辑器打开，便可以进行博文的撰写。博文支持MarkDown语法的编写,博文写好之后，在每次发布之前，我们要先将写好的博客生成静态文件，执行以下命令1hexo g 之后生成的文件会放在./public目录下，这便是我们将要部署到GitHub上的全部内容。静态文件生成之后，便可以部署到GitHub上1hexo d 设置自己的域名博客搭建好后，我们可以通过之前设置好的GitHub仓库地址来访问，比如：http://username.github.io，而且GitHub是免费替我们托管的的，如果我们想要设置自己的专属的域名，我们可以去阿里云购买域名，我们点击添加记录，设置主机记录为@，类型为A，到IP 192.30.252.153（固定值）。如下图按照如上设置完成之后， 可能不会立即生效，等个几分钟，在./source目录下新建文件CNAME（没有后缀名），文件中写上我们要绑定的域名，例如: xxxx.com，然后执行1hexo g 生成静态文件，再执行1hexo d 部署到GitHub上。这时就可以通过http://xxxx.com访问我们的博客了;","categories":[{"name":"编程","slug":"编程","permalink":"http://yoursite.com/categories/编程/"}],"tags":[{"name":"hexo 前端","slug":"hexo-前端","permalink":"http://yoursite.com/tags/hexo-前端/"}]},{"title":"js获取css样式的两种方法","slug":"js获取css样式的两种方式","date":"2017-06-28T17:08:12.000Z","updated":"2017-06-29T16:16:36.274Z","comments":true,"path":"2017/06/29/js获取css样式的两种方式/","link":"","permalink":"http://yoursite.com/2017/06/29/js获取css样式的两种方式/","excerpt":"","text":"在js中修改行间样式格式为：elem[style][属性]；也可以使用cssText:格式为：elem[style][cssText]后面接要书写的样式与属性，cssText可以接连写多个样式属性； 大家知道一般js的elem.style.属性只能获取到css都行间样式;要想获得css外联样式表的样式有两种情况分别在IE浏览器中和现代浏览器中；IE浏览器可以使用obj.currentStyle()方法，现代浏览器可以使用getComputedStyle(obj,null)[属性];;","categories":[{"name":"编程","slug":"编程","permalink":"http://yoursite.com/categories/编程/"}],"tags":[{"name":"js 前端","slug":"js-前端","permalink":"http://yoursite.com/tags/js-前端/"}]},{"title":"跨域json","slug":"跨域","date":"2016-12-30T17:08:12.000Z","updated":"2016-12-31T16:34:18.159Z","comments":true,"path":"2016/12/31/跨域/","link":"","permalink":"http://yoursite.com/2016/12/31/跨域/","excerpt":"jsonp原生写法123456789101112131415161718192021&lt;button id=&quot;btn&quot;&gt;click&lt;/button&gt;&lt;script type=&quot;text/javascript&quot;&gt; function $(str)&#123; return document.getElementById(str) &#125; //创建script标签 function CreateScript(src) &#123; var Scrip=document.createElement(&apos;script&apos;); Scrip.src=src; document.body.appendChild(Scrip); &#125; //创建callback函数 function jsonpcallback(json) &#123; console.log(json);//Object &#123; email=&quot;中国&quot;,email2=&quot;中国222&quot;&#125; &#125; //发生点击事件发起请求 $(&apos;element&apos;).onclick=function()&#123; CreateScript(&quot;http://localhost:51335/somejson?callback=jsonpcallback&quot;) &#125;&lt;/script&gt;","text":"jsonp原生写法123456789101112131415161718192021&lt;button id=&quot;btn&quot;&gt;click&lt;/button&gt;&lt;script type=&quot;text/javascript&quot;&gt; function $(str)&#123; return document.getElementById(str) &#125; //创建script标签 function CreateScript(src) &#123; var Scrip=document.createElement(&apos;script&apos;); Scrip.src=src; document.body.appendChild(Scrip); &#125; //创建callback函数 function jsonpcallback(json) &#123; console.log(json);//Object &#123; email=&quot;中国&quot;,email2=&quot;中国222&quot;&#125; &#125; //发生点击事件发起请求 $(&apos;element&apos;).onclick=function()&#123; CreateScript(&quot;http://localhost:51335/somejson?callback=jsonpcallback&quot;) &#125;&lt;/script&gt; 总结 jsonp就是利用script标签绕过同源策略，callback就是页面存在的回调方法，参数就是得到的json。 jQuery获取jsonp方法12345678910$(&quot;element&quot;).click(function () &#123; $.ajax(&#123; url: &apos;http://localhost:2701/home/somejsonp&apos;, dataType: &quot;jsonp&quot;, jsonp: &quot;callback&quot;, success: function (data) &#123; console.log(data) &#125; &#125;)&#125;)","categories":[{"name":"编程","slug":"编程","permalink":"http://yoursite.com/categories/编程/"}],"tags":[{"name":"jsonp 前端","slug":"jsonp-前端","permalink":"http://yoursite.com/tags/jsonp-前端/"}]},{"title":"一句话一个故事","slug":"一句话一个故事","date":"2016-12-24T17:08:12.000Z","updated":"2016-12-24T19:43:31.715Z","comments":true,"path":"2016/12/25/一句话一个故事/","link":"","permalink":"http://yoursite.com/2016/12/25/一句话一个故事/","excerpt":"###其实我只爱峨眉山上的云和霞，像极了十六岁那年的烟花。还记得在蒙古军营中，小郭襄有段独白，碎碎念道：可惜我迟生了二十年。倘若妈妈先生我，在生姐姐，我学会了师父的龙象般诺功和无上瑜伽密乘，在全真教道观外住下来，自称大龙女，小杨过在全真教中受欺侮，逃到我家里","text":"###其实我只爱峨眉山上的云和霞，像极了十六岁那年的烟花。还记得在蒙古军营中，小郭襄有段独白，碎碎念道：可惜我迟生了二十年。倘若妈妈先生我，在生姐姐，我学会了师父的龙象般诺功和无上瑜伽密乘，在全真教道观外住下来，自称大龙女，小杨过在全真教中受欺侮，逃到我家里，我收留了他教他武功，他慢慢的自会跟我好了。他再遇小龙女，最多不过拉住她的手，给她三枚金针，说道：小妹子，你很可爱，我心里也挺喜欢你。不过我的心已属大龙女了。请你莫怪！你有什么事看，拿一枚金针来，我一定给你办到。 附一首网络上的小诗我走过山时，山不说话，我路过海时，海不说话，小毛驴滴滴答答，倚天剑伴我走天涯。大家都说我因为爱着杨过大侠，才在峨眉山上出了家，其实我只是爱上了峨眉山上的云和霞，像极了十六岁那年的烟花。 ———-程灵素《红颜弹指老，刹那芳华》———- 我走过山的时候山不说话，我路过海的时候海不说话； 我坐着的毛驴一步一步滴滴答答，我带着的倚天剑暗哑。 大家说我因为爱着杨过大侠，找不到所以在峨眉安家； 其实我只是喜欢峨眉的雾，像十六岁那年绽放的烟花。 我路过海的时候海不说话，我走过山的时候也听不到回答； 我骑的毛驴步步滴滴答答，悠悠飘向远处可从不想要回家。 正当喜乐无忧年绍华入花，远游风尘之色却不似十九风华； 愁思袭人无机回避真牵挂，不知天涯何处有那我思恋的他。 没半点音讯怎续风陵夜话，见不到大哥哥愿知他如何行侠； 上少室山想找无色问一下，老禅师亦不知他是在何处为家。 闻琴声似和鸟语交相应答，百鸟朝凤曲难道还有人能抚它？ 白衣男子划了一画又一画，不是剑法是痴迷在那棋子围杀。 旁观者清一语道破危难局，我弹奏古曲留下了他独自惊讶； 高歌一曲轻身去不想其它，屈指昆仑三圣闯少林又有何法？ 三个老者连骑而来又回转，以为是留书之人却是少林俗家； 他从石亭顶抱着瑶琴落下，教训了青脸人只为他将我威吓； 在亭上听了我和三人对答，其实他也不知名满天下的爹妈； 这人姓何，双名叫作足道，名字谦逊得哪有半点狂妄自大？ 琴剑棋三绝技艺冠绝西域，昆仑三圣并非三人就是一个他； 抱着瑶琴到处找我为新曲，丰瞻华美奇妙调和考盘与蒹葭； 伊人难道是我，思慕如霞，右手弹琴左手使剑退敌亦惆杂。 从万里远赶来原为送句话，什么经书是在油中好让觉远拿； 平生足迹未履中土乘此游，路上碰到三个西域少林要比划； 非逼他去了剑圣名头不可，反正上少林寺一番做教我猜岔。 萍聚缘和山花与风的烂漫，我怎会不知自己是他心中的她？ 若是真能为我再弹奏一曲，或许我大哥哥找不到还有个他； 他那张嘴会说话可真不假，凭片言折服老和尚请我进奉茶； 为我一句话愿意不来打架，比剑嫌霸道青石板上把棋盘划。 觉远擦掉棋盘又将他剑夹，君宝斜击一掌他没能分身招架； 他誓用十招将这少年打发，虽取巧让君宝倒下也算输此架。 足尖一点身以在数丈之外，传完话就走人怎么忘了叫上咱？ 挑着张君宝和我觉远迅跑，到深山里面疲累过度圆寂坐化； 让伤心的少年去找我爹妈，自己却不知何去何从心乱如麻。 不是为了杨过才在峨眉住，我喜欢峨眉的雾像那年的烟花； 我身上配的倚天宝剑暗哑，昆仑何足道心头定未将我放下； 自少林飘然远去不再回头，他潇洒的身影为何却泪如雨下？","categories":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/categories/随笔/"}],"tags":[{"name":"小故事","slug":"小故事","permalink":"http://yoursite.com/tags/小故事/"}]}]}